ifelse(compactness_mean <= 16, 0.1098, 0.2085))),
symmetry_mean_score = ifelse(symmetry_mean <= 0.16, 0.14,
ifelse(symmetry_mean <= 0.18, 0.171,
ifelse(symmetry_mean <= 0.20, 0.187, 0.2495))),
radius_se_score = ifelse(radius_se <= 0.22, 0.172,
ifelse(radius_se <= 0.33, 0.274,
ifelse(radius_se <= 0.44, 0.392, 0.989))),
texture_se_score = ifelse(texture_se <= 0.90, 0.608,
ifelse(texture_se <= 1.20, 0.998,
ifelse(texture_se <= 1.50, 1.31, 2.565))),
fractal_dimension_se_score = ifelse(fractal_dimension_se <= 0.002, 0.0015575,
ifelse(fractal_dimension_se <= 0.003, 0.002675,
ifelse(fractal_dimension_se <= 0.004, 0.003815, 0.01715))))
# _score로 끝나는 모든 변수들의 합을 계산하여 score라는 새로운 열을 생성
score_02_vars <- grep("_score$", names(score_02_data), value = TRUE)
score_02_data <- score_02_data %>% mutate(score = rowSums(.[score_02_vars]))
group_B <- score_02_data$score[score_02_data$diagnosis == "B"]
group_M <- score_02_data$score[score_02_data$diagnosis == "M"]
# KS 통계량 계산
ks_result_02 <- ks.test(group_B, group_M)
# KS 통계량 출력
print(ks_result_02$statistic)
# 누적 B/M 구성비 분포 그래프 그리기
ggplot() +
stat_ecdf(data = data.frame(score = group_B, group = "B"), aes(score, colour = group)) +
stat_ecdf(data = data.frame(score = group_M, group = "M"), aes(score, colour = group)) +
labs(x = "Score", y = "Cumulative Proportion",
title = "Cumulative Distribution Plot for Score",
subtitle = "Blue: Group B, Red: Group M")
# 'B'와 'M' 진단 그룹의 실제 라벨 생성
actual <- ifelse(score_02_data$diagnosis == "B", 0, 1)
# 예측 객체 생성
pred <- prediction(score_02_data$score, actual)
# ROC 곡선 계산
roc_obj <- performance(pred, "tpr", "fpr")
# AUROC 값 계산
auc_obj <- performance(pred, "auc")
# AUROC 값 출력
print(auc_obj@y.values[[1]])
decision_values = data.frame(cut = roc_obj@alpha.values[[1]],
sensitivity = roc_obj@x.values[[1]],
specificity = roc_obj@y.values[[1]])
optimal_cut = decision_values[which.max(decision_values$sensitivity + decision_values$specificity), "cut"]
View(score_02_data)
View(score_02_data)
# AUROC 값 출력
print(auc_obj@y.values[[1]])
# AUROC 값 출력
print(auc_obj@y.values[[1]])
# 각 변수에 대해 주어진 범위에 따라 클래스와 점수를 부여
score_01_data <- selected_data %>%
mutate(radius_mean_score = ifelse(radius_mean <= 10, 1,
ifelse(radius_mean <= 13, 2,
ifelse(radius_mean <= 16, 3, 4))),
texture_mean_score = ifelse(texture_mean <= 16, 1,
ifelse(texture_mean <= 19, 2,
ifelse(texture_mean <= 22, 20.35, 27.7))),
smoothness_mean_score = ifelse(smoothness_mean <= 0.08, 1,
ifelse(smoothness_mean <= 0.09, 2,
ifelse(smoothness_mean <= 0.12, 3, 4))),
compactness_mean_score = ifelse(compactness_mean <= 0.06, 1,
ifelse(compactness_mean <= 0.09, 2,
ifelse(compactness_mean <= 16, 3, 4))),
symmetry_mean_score = ifelse(symmetry_mean <= 0.16, 1,
ifelse(symmetry_mean <= 0.18, 2,
ifelse(symmetry_mean <= 0.20, 3, 4))),
radius_se_score = ifelse(radius_se <= 0.22, 1,
ifelse(radius_se <= 0.33, 2,
ifelse(radius_se <= 0.44, 3, 4))),
texture_se_score = ifelse(texture_se <= 0.90, 1,
ifelse(texture_se <= 1.20, 2,
ifelse(texture_se <= 1.50, 3, 4))),
fractal_dimension_se_score = ifelse(fractal_dimension_se <= 0.002, 1,
ifelse(fractal_dimension_se <= 0.003, 2,
ifelse(fractal_dimension_se <= 0.004, 3, 4))))
# _score로 끝나는 모든 변수들의 합을 계산하여 score라는 새로운 열을 생성
score_01_vars <- grep("_score$", names(score_01_data), value = TRUE)
score_01_data <- score_01_data %>% mutate(score = rowSums(.[score_01_vars]))
group_B <- score_01_data$score[score_01_data$diagnosis == "B"]
group_M <- score_01_data$score[score_01_data$diagnosis == "M"]
# KS 통계량 계산
ks_result_01 <- ks.test(group_B, group_M)
# KS 통계량 출력
print(ks_result_01$statistic)
# 누적 B/M 구성비 분포 그래프 그리기
ggplot() +
stat_ecdf(data = data.frame(score = group_B, group = "B"), aes(score, colour = group)) +
stat_ecdf(data = data.frame(score = group_M, group = "M"), aes(score, colour = group)) +
labs(x = "Score", y = "Cumulative Proportion",
title = "Cumulative Distribution Plot for Score",
subtitle = "Blue: Group B, Red: Group M")
# 각 변수에 대해 주어진 범위에 따라 클래스와 점수를 부여
score_3_data <- selected_data %>%
mutate(radius_mean_score = ifelse(radius_mean <= 10, 31,
ifelse(radius_mean <= 13, 34,
ifelse(radius_mean <= 16, 37, 40))),
texture_mean_score = ifelse(texture_mean <= 16, 13,
ifelse(texture_mean <= 19, 16,
ifelse(texture_mean <= 22, 19, 22))),
smoothness_mean_score = ifelse(smoothness_mean <= 0.08, 8,
ifelse(smoothness_mean <= 0.09, 9,
ifelse(smoothness_mean <= 0.12, 10, 11))),
compactness_mean_score = ifelse(compactness_mean <= 0.06, 4,
ifelse(compactness_mean <= 0.09, 6,
ifelse(compactness_mean <= 16, 8, 10))),
symmetry_mean_score = ifelse(symmetry_mean <= 0.16, 84,
ifelse(symmetry_mean <= 0.18, 87,
ifelse(symmetry_mean <= 0.20, 90, 93))),
radius_se_score = ifelse(radius_se <= 0.22, 5,
ifelse(radius_se <= 0.33, 6,
ifelse(radius_se <= 0.44, 7, 8))),
texture_se_score = ifelse(texture_se <= 0.90, -4,
ifelse(texture_se <= 1.20, -7,
ifelse(texture_se <= 1.50, -10, -13))),
fractal_dimension_se_score = ifelse(fractal_dimension_se <= 0.002, -4,
ifelse(fractal_dimension_se <= 0.003, -5,
ifelse(fractal_dimension_se <= 0.004, -6, -7))))
# _score로 끝나는 모든 변수들의 합을 계산하여 score라는 새로운 열을 생성
score_03_vars <- grep("_score$", names(score_3_data), value = TRUE)
score_3_data <- score_3_data %>% mutate(score = rowSums(.[score_03_vars]))
group_B <- score_3_data$score[score_3_data$diagnosis == "B"]
group_M <- score_3_data$score[score_3_data$diagnosis == "M"]
# KS 통계량 계산
ks_result_03 <- ks.test(group_B, group_M)
# KS 통계량 출력
print(ks_result_03$statistic)
# 누적 B/M 구성비 분포 그래프 그리기
ggplot() +
stat_ecdf(data = data.frame(score = group_B, group = "B"), aes(score, colour = group)) +
stat_ecdf(data = data.frame(score = group_M, group = "M"), aes(score, colour = group)) +
labs(x = "Score", y = "Cumulative Proportion",
title = "Cumulative Distribution Plot for Score",
subtitle = "Blue: Group B, Red: Group M")
# 누적 B/M 구성비 분포 그래프 그리기
ggplot() +
stat_ecdf(data = data.frame(score = group_B, group = "B"), aes(score, colour = group)) +
stat_ecdf(data = data.frame(score = group_M, group = "M"), aes(score, colour = group)) +
labs(x = "Score", y = "Cumulative Proportion",
title = "Cumulative Distribution Plot for Score",
subtitle = "Blue: Group B, Red: Group M")
# 'B'와 'M' 진단 그룹의 실제 라벨 생성
actual <- ifelse(score_3_data$diagnosis == "B", 0, 1)
# 예측 객체 생성
pred <- prediction(score_3_data$score, actual)
# ROC 곡선 계산
roc_obj <- performance(pred, "tpr", "fpr")
# AUROC 값 계산
auc_obj <- performance(pred, "auc")
# AUROC 값 출력
print(auc_obj@y.values[[1]])
#
decision_values = data.frame(cut = roc_obj@alpha.values[[1]],
sensitivity = roc_obj@x.values[[1]],
specificity = roc_obj@y.values[[1]])
optimal_cut = decision_values[which.max(decision_values$sensitivity + decision_values$specificity), "cut"]
# 최종 변수 리스트
var_list <- c('radius_mean', 'texture_mean', 'smoothness_mean', 'compactness_mean', 'symmetry_mean', 'radius_se', 'texture_se', 'fractal_dimension_se')
# 분포 기반 범주화 및 범주 범위 출력
for (var in var_list) {
# 범주화
breast_cancer_train <- breast_cancer_train %>%
mutate(!!paste0(var, "_cat") := cut(!!sym(var), breaks=quantile(!!sym(var), probs=seq(0, 1, by=0.25)), include.lowest=TRUE))
# 범주 범위 출력
cat(paste("Variable:", var, "\n"))
print(summary(as.factor(breast_cancer_train[[paste0(var, "_cat")]])))
}
# 각 변수에 대해 주어진 범위에 따라 클래스와 점수를 부여
score_03_data <- selected_data %>%
mutate(radius_mean_score = ifelse(radius_mean <= 10, 9.29,
ifelse(radius_mean <= 13, 12.4,
ifelse(radius_mean <= 16, 14.3, 21.3))),
texture_mean_score = ifelse(texture_mean <= 16, 13.45,
ifelse(texture_mean <= 19, 17.55,
ifelse(texture_mean <= 22, 20.35, 27.7))),
smoothness_mean_score = ifelse(smoothness_mean <= 0.08, 0.0688,
ifelse(smoothness_mean <= 0.09, 0.0898,
ifelse(smoothness_mean <= 0.12, 0.0998, 0.134))),
compactness_mean_score = ifelse(compactness_mean <= 0.06, 0.04125,
ifelse(compactness_mean <= 0.09, 0.07635,
ifelse(compactness_mean <= 16, 0.1098, 0.2085))),
symmetry_mean_score = ifelse(symmetry_mean <= 0.16, 0.14,
ifelse(symmetry_mean <= 0.18, 0.171,
ifelse(symmetry_mean <= 0.20, 0.187, 0.2495))),
radius_se_score = ifelse(radius_se <= 0.22, 0.172,
ifelse(radius_se <= 0.33, 0.274,
ifelse(radius_se <= 0.44, 0.392, 0.989))),
texture_se_score = ifelse(texture_se <= 0.90, -0.608,
ifelse(texture_se <= 1.20, -0.998,
ifelse(texture_se <= 1.50, 1.31, -2.565))),
fractal_dimension_se_score = ifelse(fractal_dimension_se <= 0.002, -0.0015575,
ifelse(fractal_dimension_se <= 0.003, -0.002675,
ifelse(fractal_dimension_se <= 0.004, -0.003815, -0.01715))))
# _score로 끝나는 모든 변수들의 합을 계산하여 score라는 새로운 열을 생성
score_03_vars <- grep("_score$", names(score_03_data), value = TRUE)
score_03_data <- score_03_data %>% mutate(score = rowSums(.[score_03_vars]))
group_B <- score_03_data$score[score_03_data$diagnosis == "B"]
group_M <- score_03_data$score[score_03_data$diagnosis == "M"]
# KS 통계량 계산
ks_result_03 <- ks.test(group_B, group_M)
# KS 통계량 출력
print(ks_result_03$statistic)
# 누적 B/M 구성비 분포 그래프 그리기
ggplot() +
stat_ecdf(data = data.frame(score = group_B, group = "B"), aes(score, colour = group)) +
stat_ecdf(data = data.frame(score = group_M, group = "M"), aes(score, colour = group)) +
labs(x = "Score", y = "Cumulative Proportion",
title = "Cumulative Distribution Plot for Score",
subtitle = "Blue: Group B, Red: Group M")
# 'B'와 'M' 진단 그룹의 실제 라벨 생성
actual <- ifelse(score_02_data$diagnosis == "B", 0, 1)
# 예측 객체 생성
pred <- prediction(score_02_data$score, actual)
# ROC 곡선 계산
roc_obj <- performance(pred, "tpr", "fpr")
# AUROC 값 계산
auc_obj <- performance(pred, "auc")
# AUROC 값 출력
print(auc_obj@y.values[[1]])
# 'B'와 'M' 진단 그룹의 실제 라벨 생성
actual <- ifelse(score_03_data$diagnosis == "B", 0, 1)
# 예측 객체 생성
pred <- prediction(score_03_data$score, actual)
# ROC 곡선 계산
roc_obj <- performance(pred, "tpr", "fpr")
# AUROC 값 계산
auc_obj <- performance(pred, "auc")
# AUROC 값 출력
print(auc_obj@y.values[[1]])
# 각 변수에 대해 주어진 범위에 따라 클래스와 점수를 부여
score_03_data <- selected_data %>%
mutate(radius_mean_score = ifelse(radius_mean <= 10, 9.533,
ifelse(radius_mean <= 13, 12.724,
ifelse(radius_mean <= 16, 14.674, 21.858))),
texture_mean_score = ifelse(texture_mean <= 16, 5.844,
ifelse(texture_mean <= 19, 7.625,
ifelse(texture_mean <= 22, 8.842, 12.035))),
smoothness_mean_score = ifelse(smoothness_mean <= 0.08, 5.489,
ifelse(smoothness_mean <= 0.09, 7.165,
ifelse(smoothness_mean <= 0.12, 7.963, 10.692))),
compactness_mean_score = ifelse(compactness_mean <= 0.06, 1.153,
ifelse(compactness_mean <= 0.09, 2.134,
ifelse(compactness_mean <= 16, 3.069, 5.828))),
symmetry_mean_score = ifelse(symmetry_mean <= 0.16, 2.571,
ifelse(symmetry_mean <= 0.18, 3.141,
ifelse(symmetry_mean <= 0.20, 3.434, 4.583))),
radius_se_score = ifelse(radius_se <= 0.22, 0.0808,
ifelse(radius_se <= 0.33, 1.287,
ifelse(radius_se <= 0.44, 1.842, 4.648))),
texture_se_score = ifelse(texture_se <= 0.90, -0.895,
ifelse(texture_se <= 1.20, -1.469,
ifelse(texture_se <= 1.50, -1.929, -3.777))),
fractal_dimension_se_score = ifelse(fractal_dimension_se <= 0.002, -0.585,
ifelse(fractal_dimension_se <= 0.003, -1.004,
ifelse(fractal_dimension_se <= 0.004, -1.433, -6.443))))
# _score로 끝나는 모든 변수들의 합을 계산하여 score라는 새로운 열을 생성
score_03_vars <- grep("_score$", names(score_3_data), value = TRUE)
score_03_data <- score_03_data %>% mutate(score = rowSums(.[score_03_vars]))
group_B <- score_3_data$score[score_3_data$diagnosis == "B"]
group_M <- score_3_data$score[score_3_data$diagnosis == "M"]
# KS 통계량 계산
ks_result_03 <- ks.test(group_B, group_M)
# KS 통계량 출력
print(ks_result_03$statistic)
# 누적 B/M 구성비 분포 그래프 그리기
ggplot() +
stat_ecdf(data = data.frame(score = group_B, group = "B"), aes(score, colour = group)) +
stat_ecdf(data = data.frame(score = group_M, group = "M"), aes(score, colour = group)) +
labs(x = "Score", y = "Cumulative Proportion",
title = "Cumulative Distribution Plot for Score",
subtitle = "Blue: Group B, Red: Group M")
# 'B'와 'M' 진단 그룹의 실제 라벨 생성
actual <- ifelse(score_3_data$diagnosis == "B", 0, 1)
# 예측 객체 생성
pred <- prediction(score_3_data$score, actual)
# ROC 곡선 계산
roc_obj <- performance(pred, "tpr", "fpr")
# AUROC 값 계산
auc_obj <- performance(pred, "auc")
# AUROC 값 출력
print(auc_obj@y.values[[1]])
# 'B'와 'M' 진단 그룹의 실제 라벨 생성
actual <- ifelse(score_03_data$diagnosis == "B", 0, 1)
# 예측 객체 생성
pred <- prediction(score_03_data$score, actual)
# ROC 곡선 계산
roc_obj <- performance(pred, "tpr", "fpr")
# AUROC 값 계산
auc_obj <- performance(pred, "auc")
# AUROC 값 출력
print(auc_obj@y.values[[1]])
# 각 변수에 대해 주어진 범위에 따라 클래스와 점수를 부여
score_01_data <- selected_data %>%
mutate(radius_mean_score = ifelse(radius_mean <= 10, 1,
ifelse(radius_mean <= 13, 2,
ifelse(radius_mean <= 16, 3, 4))),
texture_mean_score = ifelse(texture_mean <= 16, 1,
ifelse(texture_mean <= 19, 2,
ifelse(texture_mean <= 22, 20.35, 27.7))),
smoothness_mean_score = ifelse(smoothness_mean <= 0.08, 1,
ifelse(smoothness_mean <= 0.09, 2,
ifelse(smoothness_mean <= 0.12, 3, 4))),
compactness_mean_score = ifelse(compactness_mean <= 0.06, 1,
ifelse(compactness_mean <= 0.09, 2,
ifelse(compactness_mean <= 16, 3, 4))),
symmetry_mean_score = ifelse(symmetry_mean <= 0.16, 1,
ifelse(symmetry_mean <= 0.18, 2,
ifelse(symmetry_mean <= 0.20, 3, 4))),
radius_se_score = ifelse(radius_se <= 0.22, 1,
ifelse(radius_se <= 0.33, 2,
ifelse(radius_se <= 0.44, 3, 4))),
texture_se_score = ifelse(texture_se <= 0.90, 1,
ifelse(texture_se <= 1.20, 2,
ifelse(texture_se <= 1.50, 3, 4))),
fractal_dimension_se_score = ifelse(fractal_dimension_se <= 0.002, 1,
ifelse(fractal_dimension_se <= 0.003, 2,
ifelse(fractal_dimension_se <= 0.004, 3, 4))))
# _score로 끝나는 모든 변수들의 합을 계산하여 score라는 새로운 열을 생성
score_01_vars <- grep("_score$", names(score_01_data), value = TRUE)
score_01_data <- score_01_data %>% mutate(score = rowSums(.[score_01_vars]))
group_B <- score_01_data$score[score_01_data$diagnosis == "B"]
group_M <- score_01_data$score[score_01_data$diagnosis == "M"]
# KS 통계량 계산
ks_result_01 <- ks.test(group_B, group_M)
# KS 통계량 출력
print(ks_result_01$statistic)
# 누적 B/M 구성비 분포 그래프 그리기
ggplot() +
stat_ecdf(data = data.frame(score = group_B, group = "B"), aes(score, colour = group)) +
stat_ecdf(data = data.frame(score = group_M, group = "M"), aes(score, colour = group)) +
labs(x = "Score", y = "Cumulative Proportion",
title = "Cumulative Distribution Plot for Score",
subtitle = "Blue: Group B, Red: Group M")
# 'B'와 'M' 진단 그룹의 실제 라벨 생성
actual <- ifelse(score_01_data$diagnosis == "B", 0, 1)
# 예측 객체 생성
pred <- prediction(score_01_data$score, actual)
# ROC 곡선 계산
roc_obj <- performance(pred, "tpr", "fpr")
# AUROC 값 계산
auc_obj <- performance(pred, "auc")
# AUROC 값 출력
print(auc_obj@y.values[[1]])
# 각 변수에 대해 주어진 범위에 따라 클래스와 점수를 부여
score_03_data <- selected_data %>%
mutate(radius_mean_score = ifelse(radius_mean <= 10, 9.5,
ifelse(radius_mean <= 13, 12.7,
ifelse(radius_mean <= 16, 14.6, 21.8))),
texture_mean_score = ifelse(texture_mean <= 16, 5.8,
ifelse(texture_mean <= 19, 7.6,
ifelse(texture_mean <= 22, 8.8, 12.0))),
smoothness_mean_score = ifelse(smoothness_mean <= 0.08, 5.4,
ifelse(smoothness_mean <= 0.09, 7.1,
ifelse(smoothness_mean <= 0.12, 7.9, 10.6))),
compactness_mean_score = ifelse(compactness_mean <= 0.06, 1.1,
ifelse(compactness_mean <= 0.09, 2.1,
ifelse(compactness_mean <= 16, 3.0, 5.8))),
symmetry_mean_score = ifelse(symmetry_mean <= 0.16, 2.5,
ifelse(symmetry_mean <= 0.18, 3.1,
ifelse(symmetry_mean <= 0.20, 3.4, 4.5))),
radius_se_score = ifelse(radius_se <= 0.22, 0.8,
ifelse(radius_se <= 0.33, 1.2,
ifelse(radius_se <= 0.44, 1.8, 4.6))),
texture_se_score = ifelse(texture_se <= 0.90, -0.8,
ifelse(texture_se <= 1.20, -1.4,
ifelse(texture_se <= 1.50, -1.9, -3.7))),
fractal_dimension_se_score = ifelse(fractal_dimension_se <= 0.002, -0.5,
ifelse(fractal_dimension_se <= 0.003, -1.0,
ifelse(fractal_dimension_se <= 0.004, -1.4, -6.4))))
# _score로 끝나는 모든 변수들의 합을 계산하여 score라는 새로운 열을 생성
score_03_vars <- grep("_score$", names(score_03_data), value = TRUE)
score_03_data <- score_03_data %>% mutate(score = rowSums(.[score_03_vars]))
group_B <- score_03_data$score[score_03_data$diagnosis == "B"]
group_M <- score_03_data$score[score_03_data$diagnosis == "M"]
# KS 통계량 계산
ks_result_03 <- ks.test(group_B, group_M)
# KS 통계량 출력
print(ks_result_03$statistic)
# 누적 B/M 구성비 분포 그래프 그리기
ggplot() +
stat_ecdf(data = data.frame(score = group_B, group = "B"), aes(score, colour = group)) +
stat_ecdf(data = data.frame(score = group_M, group = "M"), aes(score, colour = group)) +
labs(x = "Score", y = "Cumulative Proportion",
title = "Cumulative Distribution Plot for Score",
subtitle = "Blue: Group B, Red: Group M")
# 'B'와 'M' 진단 그룹의 실제 라벨 생성
actual <- ifelse(score_03_data$diagnosis == "B", 0, 1)
# 예측 객체 생성
pred <- prediction(score_03_data$score, actual)
# ROC 곡선 계산
roc_obj <- performance(pred, "tpr", "fpr")
# AUROC 값 계산
auc_obj <- performance(pred, "auc")
# AUROC 값 출력
print(auc_obj@y.values[[1]])
View(score_03_data)
knitr::opts_chunk$set(echo = TRUE)
# 점수 확인
result_score
# 예측 객체 생성
pred <- prediction(score_03_data$score, actual)
# 최적의 임계값 찾기
perf <- performance(pred, "sens", "spec")
decision.values <- data.frame(cut = perf@alpha.values[[1]],
sensitivity = perf@x.values[[1]],
specificity = perf@y.values[[1]])
optimal.cut <- decision.values[which.max(decision.values$sensitivity + decision.values$specificity), "cut"]
# 최적의 임계값 출력
print(optimal.cut)
# 함수 생성
calculate_score_and_diagnose <- function(data) {
data <- data %>%
mutate(radius_mean_score = ifelse(radius_mean <= 10, 9.5,
ifelse(radius_mean <= 13, 12.7,
ifelse(radius_mean <= 16, 14.6, 21.8))),
texture_mean_score = ifelse(texture_mean <= 16, 5.8,
ifelse(texture_mean <= 19, 7.6,
ifelse(texture_mean <= 22, 8.8, 12.0))),
smoothness_mean_score = ifelse(smoothness_mean <= 0.08, 5.4,
ifelse(smoothness_mean <= 0.09, 7.1,
ifelse(smoothness_mean <= 0.12, 7.9, 10.6))),
compactness_mean_score = ifelse(compactness_mean <= 0.06, 1.1,
ifelse(compactness_mean <= 0.09, 2.1,
ifelse(compactness_mean <= 16, 3.0, 5.8))),
symmetry_mean_score = ifelse(symmetry_mean <= 0.16, 2.5,
ifelse(symmetry_mean <= 0.18, 3.1,
ifelse(symmetry_mean <= 0.20, 3.4, 4.5))),
radius_se_score = ifelse(radius_se <= 0.22, 0.8,
ifelse(radius_se <= 0.33, 1.2,
ifelse(radius_se <= 0.44, 1.8, 4.6))),
texture_se_score = ifelse(texture_se <= 0.90, -0.8,
ifelse(texture_se <= 1.20, -1.4,
ifelse(texture_se <= 1.50, -1.9, -3.7))),
fractal_dimension_se_score = ifelse(fractal_dimension_se <= 0.002, -0.5,
ifelse(fractal_dimension_se <= 0.003, -1.0,
ifelse(fractal_dimension_se <= 0.004, -1.4, -6.4))))
score_vars <- grep("_score$", names(data), value = TRUE)
data <- data %>% mutate(score = rowSums(.[score_vars]))
data <- data %>% mutate(diagnosis = ifelse(score > 35, "M", "B"))
return(data)
}
# valdation 데이터 이용
sample_data <- breast_cancer_valid %>%
select(id, diagnosis, radius_mean, texture_mean, smoothness_mean, compactness_mean,
symmetry_mean,radius_se, texture_se, fractal_dimension_se)
# plotting and reshaping data
library(tidyverse)
library(GGally)
library(reshape)
# Correlation
library(corrplot)
# Confusion Matrix
library(caret)
# ROC Curve
library(ROCR)
# Model
library(rpart)
library(rpart.plot)
library(randomForest)
# Plot combine
library(gridExtra)
# valdation 데이터 이용
sample_data <- breast_cancer_valid %>%
select(id, diagnosis, radius_mean, texture_mean, smoothness_mean, compactness_mean,
symmetry_mean,radius_se, texture_se, fractal_dimension_se)
# diagnosis가 'M'인 첫 번째 행 선택
M_data <- selected_data %>%
filter(diagnosis == 'M') %>%
slice(1)
# diagnosis가 'B'인 첫 번째 행 선택
B_data <- selected_data %>%
filter(diagnosis == 'B') %>%
slice(1)
M_data # Malignant(악성=M)인 환자데이터
B_data # Benign(양성=B)인 환자데이터
table(result_score)
# 점수 확인
result_score
# B_data # Benign(양성=B)인 환자데이터
use_data = B_data
result <- calculate_score_and_diagnose(use_data)
# 첫번째 그래프
# "_score"로 끝나는 변수만 선택합니다.
result_score <- dplyr::select(result, ends_with("_score"))
# 데이터를 길게 변형합니다.
result_score_long <- tidyr::pivot_longer(result_score, everything(), names_to = "variable", values_to = "value")
# 막대그래프를 그립니다.
p1 <- ggplot(result_score_long, aes(x = variable, y = value)) +
geom_bar(stat = "identity", width = 0.5) +
coord_flip() +
labs(x = "Variable", y = "Score for each variable", title = "Score")
# 두번째 그래프
# "score" 열만 선택합니다.
result_score <- result$score
# 데이터 프레임을 생성합니다.
df <- data.frame(score = result_score)
# 막대그래프를 그립니다.
p2 <-  ggplot(df, aes(x = "", y = score, fill = (score > 35))) +
geom_bar(stat = "identity", width = 0.4) +
scale_fill_manual(values = c("TRUE" = "#6AD3D6", "FALSE" = "#F2ABA6"), labels = c("TRUE" = "Malignant", "FALSE" = "Benign"), name = "diagnosis") +
ylim(0,50) +
geom_hline(yintercept = 35, linetype = "dashed", color = "red") +
geom_text(aes(label=score), vjust=-0.3, size=3.5) +
theme_bw() +
labs(title = "Total score", x = "Total score", y = "Score")
# 점수 확인
result_score
# 두 그래프를 합칩니다.
grid.arrange(p1, p2, ncol=2, widths = c(3, 1))  # p1과 p2의 비율을 3:1로 설정합니다.
# 점수 확인
result_score
# 점수 확인
result_score_long
